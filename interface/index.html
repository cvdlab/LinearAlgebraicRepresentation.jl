<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interface · LinearAlgebraicRepresentation.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/lar.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="LinearAlgebraicRepresentation.jl logo"/></a><h1>LinearAlgebraicRepresentation.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../lar/">L.A.R. Intro</a></li><li class="current"><a class="toctext" href>Interface</a><ul class="internal"><li><a class="toctext" href="#Introduction-1">Introduction</a></li><li><a class="toctext" href="#Data-structures-1">Data structures</a></li><li><a class="toctext" href="#Main-Interface-1">Main Interface</a></li></ul></li><li><a class="toctext" href="../arrangement/">Arrangement</a></li><li><span class="toctext">Parametric primitives</span><ul><li><a class="toctext" href="../mapper/">Mapper</a></li><li><a class="toctext" href="../struct/">Assemblies</a></li></ul></li><li><span class="toctext">Grid generation</span><ul><li><a class="toctext" href="../largrid/">Cuboidal grids</a></li><li><a class="toctext" href="../simplexn/">Simplicial grids</a></li></ul></li><li><a class="toctext" href="../integr/">Domain integration</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Interface</a></li></ul><a class="edit-page" href="https://github.com/cvdlab/LinearAlgebraicRepresentation.jl/blob/master/docs/src/interface.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Interface</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Interface-to-cell-and-chain-complexes-1" href="#Interface-to-cell-and-chain-complexes-1">Interface to cell and chain complexes</a></h1><p>Most part of text in this page is derived from <a href="."></a> and from <a href="."></a>.</p><h2><a class="nav-anchor" id="Introduction-1" href="#Introduction-1">Introduction</a></h2><p>With increased complexity of geometric data, <strong>topological models</strong> play an increasingly important role beyond <em>boundary representations</em>, <em>assemblies</em>, <em>finite elements</em>, <em>image processing</em>, and other traditional modeling applications. While many graph- and index- based data structures have been proposed, no standard representation has emerged as of now. Furthermore, such representations typically do not deal with representations of mappings and functions and do not scale to support parallel processing, open source, and client-based architectures. </p><p>A proper mathematical model for all topological structures is a <strong>(co)chain complex</strong>: a sequence of linear <strong>(co)chain spaces</strong> and linear <strong>(co)boundary mappings</strong>. This in turn implies all topological structures may be represented by <strong>a collection of sparse matrices</strong>. We propose a <strong>Linear Algebraic Representation (LAR)</strong> scheme for <span>$mod 2$</span> (co)chain complexes using CSC sparse matrices and show that it supports variety of topological computations using standard matrix algebra, without any overhead in space or running time. With the LAR scheme, only the <em>characteristic functions</em> (see below) of <span>$d$</span>-cells as vertex subsets are necessary for representing <em>polytopal complexes</em>. Examples include simplicial, cubical, and Voronoi complexes.</p><h2><a class="nav-anchor" id="Data-structures-1" href="#Data-structures-1">Data structures</a></h2><p>All types of cell complexes and functions over cell complexes are properly represented by a (co)chain complex, that captures all combinatorial relationships of interest in solid and physical modeling formally and unambiguously. According to classical results from algebraic topology techniques, a (co)chain complex and all associated combinatorial operations are readily represented using <em>standard techniques</em> from linear algebra, giving rise to a <em>Linear Algebraic Represention</em> (LAR) scheme.</p><p>In this package, we provide LAR data structures and algorithms using <em>compressed sparse column (CSC) matrices</em>, that introduce no computational overhead and are asymptotically as efficient as (and usually better than) many other popular topological data structures. Our aim is to provide a representation that supports all topological constructions and queries that arise in typical <em>cellular decomposition</em> of space (mesh, image, boundary, etc).</p><p>An <strong>arrangement</strong> is the <em>decomposition of d-dimensional space</em> into connected and <em>relatively open cells</em> of lower dimensions, induced by an intersection of a finite collection of geometric objects. A <em>planar collection</em> S may include line segments, open or closed polygonal lines, polygons, two-dimensional meshes, and discrete images in 2D. A <em>space collection</em> may include 3D polygons, polygonal meshes, B-reps of solid models—either manifold or non-manifold, three-dimensional CAE meshes, and volumetric images in 3D.</p><p>In this package, we have implemented the <em>computation of the arrangement</em> produced by a  <em>set of cellular complexes</em> in either 2D or 3D. Our goal is to provide a complete description of the plane or space decomposition induced by the input, into cells of dimensions 0, 1, 2 or 3.</p><h3><a class="nav-anchor" id="Characteristic-matrices-1" href="#Characteristic-matrices-1">Characteristic matrices</a></h3><p>A precise mathematical definition of a cellular complex is not trivial; we may rely on the intuitive idea of constructing a space <em>by gluing together</em> a number of <em>building blocks</em> of different dimensions, called <strong>cells</strong>.</p><p>The <strong>characteristic function</strong> <span>$\chi _A : S \to \{ 0, 1 \}$</span> is a function defined on a set <span>$S = \{s_j\}$</span>, that indicates membership of an element <span>$s_j$</span> in a subset <span>$A \subseteq S$</span>, having the value 1 for all elements of <span>$A$</span> and the value 0 for all elements of <span>$S$</span> not in <span>$A$</span>. We call <strong>characteristic matrix</strong> <span>$M$</span> of a collection of subsets <span>$A_i \subseteq S$</span>  <span>$(i=1,...,n)$</span> the binary matrix <span>$M=(m_{ij})$</span>, with <span>$m_{ij} = \chi_{A_i}(s_j)$</span>.</p><h4><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h4><p>Binary matrix representing by rows the <code>p</code>-cells of a cellular complex. The input parameter must be of <code>Cells</code> type. Return a sparse binary matrix,  providing the basis of a <span>$Chain$</span> space of given dimension. Notice that the  number of columns is equal to the number of vertices (0-cells). </p><p>First the cellular complex describing the 0-, 1-, 2-, anf 3-faces of a single unit cube is generated. </p><pre><code class="language-julia">V,(VV,EV,FV,CV) = Lar.cuboid([1.,1.,1.], true); </code></pre><p>Then, we may see the characteristic matrix of 1-cells (edges), with two ones per row:</p><pre><code class="language-julia">julia&gt; Lar = LinearAlgebraicRepresentation

julia&gt; Matrix(Lar.characteristicMatrix(EV))
12×8 Array{Int8,2}:
 1  1  0  0  0  0  0  0
 0  0  1  1  0  0  0  0
 0  0  0  0  1  1  0  0
 0  0  0  0  0  0  1  1
 1  0  1  0  0  0  0  0
 0  1  0  1  0  0  0  0
 0  0  0  0  1  0  1  0
 0  0  0  0  0  1  0  1
 1  0  0  0  1  0  0  0
 0  1  0  0  0  1  0  0
 0  0  1  0  0  0  1  0
 0  0  0  1  0  0  0  1</code></pre><p>and of 2-cells (faces):</p><pre><code class="language-julia">julia&gt; Matrix(Lar.characteristicMatrix(FV))
6×8 Array{Int8,2}:
 1  1  1  1  0  0  0  0
 0  0  0  0  1  1  1  1
 1  1  0  0  1  1  0  0
 0  0  1  1  0  0  1  1
 1  0  1  0  1  0  1  0
 0  1  0  1  0  1  0  1</code></pre><p>Finally, the boundary of the single 3-cell contains all the 0-cells (vertices). Of course, the 3D cube has 12 edges in <code>EV</code>, 6 faces in <code>FV</code>, and one 3-cell in <code>CV</code>:</p><pre><code class="language-julia">julia&gt; Matrix(Lar.characteristicMatrix(CV))
1×8 Array{Int8,2}:
 1  1  1  1  1  1  1  1</code></pre><h3><a class="nav-anchor" id="Chain-bases-1" href="#Chain-bases-1">Chain bases</a></h3><p>In algebraic topology, a <span>$k$</span>-chain is a <em>formal linear combination</em> of the <span>$k$</span>-cells in a cell complex. In <em>simplicial</em> complexes (respectively, <em>cubical</em> complexes), <span>$k$</span>-chains are combinations of <span>$k$</span>-simplices (respectively, <span>$k$</span>-cubes).</p><p>Let <span>$\sigma$</span> be an oriented cell in <span>$X$</span> and <span>$\mu \in G$</span>. The elementary chain whose value is <span>$\mu$</span> on <span>$\sigma$</span>, <span>$-\mu$</span> on <span>$-\sigma$</span> and <span>$0$</span> on any other cell in <span>$X$</span> is denoted <span>$\mu\sigma$</span> . Each chain can then be written in a <em>unique way</em> as a <em>sum of elementary chains</em>. With abuse of notation, we do NOT distinguish between <em>cells</em> and <em>singleton chains</em> (i.e., the elementary chains whose value is <span>$1\sigma$</span> for some cell <span>$\sigma$</span>), used as elements of the <strong>standard bases</strong> of chain groups.</p><p>Chains are often thought of as <em>attaching orientation</em> and <em>multiplicity</em> to cells: if coefficients are extracted from the group <span>$G = (\{ −1, 0, 1 \}, +) ≃ (\mathbf{Z}_3, +)$</span>, then cells can only be discarded or selected, possibly inverting their orientation.  A <em><span>$p$</span>-cycle</em> is a <em>closed <span>$p$</span>-chain</em>, i.e. a <span>$p$</span>-chain <em>without boundary</em>.  It is useful to select a conventional choice to orient the singleton chains (<em>single cells</em>) automatically. 0-cells are considered all positive. The <span>$p$</span>-cells, for <span>$1 ≤ p ≤ d-1$</span>, can be given an <em>internal orientation</em> according to the orientation of the first (<span>$p − 1$</span>)-cell in their <em>canonical representation</em>, i.e. sorted on indices of their (<span>$p − 1$</span>)-cycle. Finally, a <span>$d$</span>-cell may be oriented as the sign of its <span>$oriented volume$</span>.</p><h4><a class="nav-anchor" id="Examples-2" href="#Examples-2">Examples</a></h4><p>A compact representation of bases of <span>$p$</span>-cells is provided by <code>Cells</code> type, defined as <code>Array{Array{Int,1}}</code>, where each element codifies a cell as the array of indices to vertices on the boundary of the cell:</p><pre><code class="language-julia">julia&gt; V,(VV,EV,FV,CV) = Lar.cuboid([1.,1.,1.], true);

julia&gt; FV
6-element Array{Array{Int64,1},1}:
 [1, 2, 3, 4]
 [5, 6, 7, 8]
 [1, 2, 5, 6]
 [3, 4, 7, 8]
 [1, 3, 5, 7]
 [2, 4, 6, 8]</code></pre><p>A simplicial decomposition of the unit cube with six 3-cells (tetrahedra), and a simplicial decomposition of the domain <span>$[0,5] \times [0,1]$</span> with ten 2-cells (triangles) follows:</p><pre><code class="language-julia">julia&gt; V,CV = Lar.simplexGrid([1,1,1]);

julia&gt; V
3×8 Array{Float64,2}:
 0.0  1.0  0.0  1.0  0.0  1.0  0.0  1.0
 0.0  0.0  1.0  1.0  0.0  0.0  1.0  1.0
 0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0

julia&gt; CV   # bases of tetrahedra
6-element Array{Array{Int64,1},1}:
 [1, 2, 3, 5]
 [2, 3, 5, 6]
 [3, 5, 6, 7]
 [2, 3, 4, 6]
 [3, 4, 6, 7]
 [4, 6, 7, 8]

julia&gt; W,FW = Lar.simplexGrid([5,1]);

julia&gt; W
2×12 Array{Float64,2}:
 0.0  1.0  2.0  3.0  4.0  5.0  0.0  1.0  2.0  3.0  4.0  5.0
 0.0  0.0  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0  1.0  1.0

julia&gt; FW   # bases of triangles
10-element Array{Array{Int64,1},1}:
 [1, 2, 7]  
 [2, 7, 8]  
 [2, 3, 8]  
 [3, 8, 9]  
 [3, 4, 9]  
 [4, 9, 10] 
 [4, 5, 10] 
 [5, 10, 11]
 [5, 6, 11] 
 [6, 11, 12]</code></pre><p>It is worthwhile to note that the above examples provide <span>$p$</span>-bases of suitable dimensions, equal to the number of <span>$p$</span>-cells,  for the corresponding chain complexes.   </p><h3><a class="nav-anchor" id="(Co)boundary-operators-1" href="#(Co)boundary-operators-1">(Co)boundary operators</a></h3><p><strong>Boundary operators</strong> are maps <span>$\partial_p : C_p \to C_{p−1}$</span> between chain spaces, i.e. between spaces of subsets of cells with different dimension, with <span>$1 \leq p \leq d$</span>, hence for a <em>cellular 2-complex</em> we have two operators, denoted as <span>$\partial_2 : C_2 \to C_1$</span> and <span>$\partial_1 : C_1 \to C_0$</span>, respectively. Since they are linear maps between linear spaces, may be represented by matrices of coefficients <span>$[\partial_2]$</span> and <span>$[\partial_1]$</span> from the corresponding groups. We use the groups <span>$\{0, 1\}$</span> and <span>$\{-1, 0, 1\}$</span> for <em>unsigned</em> and <em>signed</em> coefficients, respectively.</p><p>The concept of <em>cochain</em>  in a group <span>$C^p$</span> of linear maps from chains <span>$C_p \to \Re$</span> allows for the <em>association of numbers</em> not only to <em>single cells</em>, as done by chains, but also to <em>assemblies of cells</em>. A cochain is hence the association of every discretized subdomain (chain) of a cell complex with a numeric quantity, usually resulting from a <em>discrete integration</em> over a chain.</p><p><strong>Coboundary operators</strong> are maps <span>$\delta^p : C^{p} \to C^{p+1}$</span>, with each linear space  <span>$C^p$</span> of <span>$p$</span>-cochains isomorphic to the space <span>$C_p$</span> of <span>$p$</span>-chain. Therefore in this package only Chain spaces are used. Notice that <span>$[\partial_p] = [\delta^p]^t$</span>. This property is often utilized in our algorithms.</p><h4><a class="nav-anchor" id="Examples-3" href="#Examples-3">Examples</a></h4><pre><code class="language-julia">julia&gt; V,(VV,EV,FV,CV) = Lar.cuboid([1.,1.,1.], true);

julia&gt; EV
12-element Array{Array{Int64,1},1}:
 [1, 2]
 [3, 4]
   ...
 [3, 7]
 [4, 8]

julia&gt; Lar.boundary_1( EV::Lar.Cells )
8×12 SparseMatrixCSC{Int8,Int64} with 24 stored entries:
  [1 ,  1]  =  -1
  [2 ,  1]  =  1
  [3 ,  2]  =  -1
	...       ...
  [7 , 11]  =  1
  [4 , 12]  =  -1
  [8 , 12]  =  1

julia&gt; Matrix(Lar.boundary_1(EV::Cells))
8×12 Array{Int8,2}:
 -1   0   0   0  -1   0   0   0  -1   0   0   0
  1   0   0   0   0  -1   0   0   0  -1   0   0
  0  -1   0   0   1   0   0   0   0   0  -1   0
  0   1   0   0   0   1   0   0   0   0   0  -1
  0   0  -1   0   0   0  -1   0   1   0   0   0
  0   0   1   0   0   0   0  -1   0   1   0   0
  0   0   0  -1   0   0   1   0   0   0   1   0
  0   0   0   1   0   0   0   1   0   0   0   1</code></pre><p>Notice that the matrix <span>$[\partial_1]$</span>,  generated by the function <code>boundary_1</code> applied to the 1-cell basis <code>EV</code>, contains two non-zero elements per column, where the associated edge (1-cell) is oriented from the vertex (row) of lesser index, towards the vertex of greater index, according to our numbering convention.</p><h3><a class="nav-anchor" id="Chain-complexes-1" href="#Chain-complexes-1">Chain complexes</a></h3><p>A <strong>chain complex</strong>, for our purposes, is an algebraic structure that consists of <em>a sequence of linear spaces</em>  and a <em>sequence of linear maps</em> between consecutive linear spaces,  such that the <strong>image</strong> of each map (subspace of <em>boundaries</em> of <span>$p$</span>-chains) is included in the <strong>kernel</strong> (subspace of <em>cycles</em> of <span>$(p-1)$</span>-chains) of the next. </p><p>The set of all <span>$k$</span>-chains forms a group and the <em>sequence of these groups</em> is called a <strong>chain complex</strong>. In computing the arrangement <span>$A(S)$</span> induced by <span>$S$</span>, we actually compute the whole chain complex <span>$C\bullet$</span> generated by the cell complex <span>$X := A(S)$</span>. For example, in 3D we compute all objects and arrows (morphisms) in the diagram below, and hence we obtain a computational knowledge of space subdivision homology, including the Euler number. </p><h4><a class="nav-anchor" id="Examples-4" href="#Examples-4">Examples</a></h4><p>From the minimal possible input, construct the whole two-dimensional chain complex, i.e. the bases for linear spaces C<em>1 and  C</em>2, of 1-chains and  2-chains, and the signed coboundary operators from  C<em>0 to C</em>1 and from C<em>1 to C</em>2.</p><h5><a class="nav-anchor" id="D-Chain-complex-1" href="#D-Chain-complex-1">2D Chain complex</a></h5><p>Start with the 1-skeleton (set of 1-cells) of a 2D small cuboidal grid (made of squares); in other words, suppose we only know the edges of the grid:</p><pre><code class="language-julia">julia&gt; W = 
 [0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0  2.0  2.0  2.0  2.0  3.0  3.0  3.0  3.0
  0.0  1.0  2.0  3.0  0.0  1.0  2.0  3.0  0.0  1.0  2.0  3.0  0.0  1.0  2.0  3.0]
# output  
 2×16 Array{Float64,2}: ...

julia&gt; EW = 
[[1, 2],[2, 3],[3, 4],[5, 6],[6, 7],[7, 8],[9, 10],[10, 11],[11, 12],[13, 14],
 [14, 15],[15, 16],[1, 5],[2, 6],[3, 7],[4, 8],[5, 9],[6, 10],[7, 11],[8, 12],
 [9, 13],[10, 14],[11, 15],[12, 16]]
# output  
24-element Array{Array{Int64,1},1}: ...</code></pre><p>We go to compute the arrangement of the 2D space induced by the above, i.e. the full <strong>chain complex</strong> generated by <code>(W,EW)</code>. This one is returned by the evaluation of the expression <code>chaincomplex(W,EW)</code>. The output variable <code>bases</code>  will contain the meaningful cell bases, i.e. those of dimension 1 and 2, since dimension 0 – isolated 0-cells – is not so.</p><pre><code class="language-julia">julia&gt; V,bases,coboundaries = Lar.chaincomplex(W,EW)

julia&gt; bases[1]	# edges
24-element Array{Array{Int64,1},1}: ...

julia&gt; bases[2] # faces -- previously unknown !!
9-element Array{Array{Int64,1},1}: ...</code></pre><p>Analogously, the <code>coboundaries</code> variable will contain the <span>$[\delta_1]$</span> and <span>$[\delta_2]$</span> matrices, of type <code>SparseMatrixCSC{Int8,Int64}</code></p><pre><code class="language-julia">julia&gt; coboundaries[1] # coboundary_1 
24×16 SparseMatrixCSC{Int8,Int64} with 48 stored entries: ...

julia&gt; Matrix(coboundaries[2]) # coboundary_1: faces as oriented 1-cycles of edges
9×24 Array{Int8,2}:
 -1  0  0  1  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0  0  0  0  0  0
  0 -1  0  0  1  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0  0  0  0  0
  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0  0  0  0
  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0  0
  0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0
  0  0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  1 -1  0  0  0  0
  0  0  0  0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  0  1 -1  0
  0  0  0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  0  1 -1  0  0
  0  0  0  0  0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  0  1 -1</code></pre><p>Note that the last matrix contains by rows the 2-cycles corresponding to the (previously) unknown 2-basis <code>FV</code> that can now be easily computed. Notice also that columns corresponding to <em>interior edges</em> (1-cells) contain two non-zeros <em>of opposite sign</em>. Hence the computed 2-complex is <strong>coherently oriented</strong> by the matrix rows, actually by construction. </p><p>The 2-boundary operator matrix, i.e. <code>transpose(coboundaries[2])</code>, can be used to compute the boundary of every possible 2-chain, by matrix multiplication times the coordinate (binary) representation of the 2-chain, implemented by the type <code>Chain</code>, defined as <code>SparseVector{Int8, Int}</code>.</p><h5><a class="nav-anchor" id="D-Chain-complex-2" href="#D-Chain-complex-2">3D Chain complex</a></h5><p>The example discussed here concerns two unit cubes in 3D, where the second is rotated and translated, up to intersect only partially the firat cube. First we prepare our data, using a very simple hierarchical aggregation via a <code>Struct</code> object, to get a representation of faces and edges of both cubes in two <code>Cells</code> arrays <code>FV</code> and <code>EV</code>.</p><pre><code class="language-julia">julia&gt; cube_1 = ([0 0 0 0 1 1 1 1; 0 0 1 1 0 0 1 1; 0 1 0 1 0 1 0 1], 
[[1,2,3,4],[5,6,7,8],[1,2,5,6],[3,4,7,8],[1,3,5,7],[2,4,6,8]], 
[[1,2],[3,4],[5,6],[7,8],[1,3],[2,4],[5,7],[6,8],[1,5],[2,6],[3,7],[4,8]] )

julia&gt; cube_2 = Lar.Struct([Lar.t(0,0,0.5), Lar.r(0,0,pi/3), cube_1])

julia&gt; V,FV,EV = Lar.struct2lar(Lar.Struct([ cube_1, cube_2 ]))</code></pre><p>Then we compute the 3D space arrangement induced by <code>FV</code>, providing the auxiliary information in <code>EV</code>, and getting back <code>V,</code>bases<code>,coboundaries</code>. Both <code>bases</code> and <code>coboundaries</code> are then disassembled into their component data structures. The <em>actual discoveries</em> computed by the <code>arrangement</code> algorithms, called by the <code>chaincomplex</code> function, are the NEW <code>EV</code>, <code>FV</code>, <code>CV</code> basis and the <code>cscEV, cscFE, cscCF</code> operators, which stands  for <span>$[\delta_0]$</span>,<span>$[\delta_1]$</span>, and<span>$[\delta_2]$</span>, i.e. the <strong>computations of the solid 3D cells</strong> generated by the arrangement of space, including their <strong>full topology</strong>.</p><pre><code class="language-julia">julia&gt; V,bases,coboundaries = Lar.chaincomplex(V,FV,EV)

julia&gt; (EV, FV, CV), (cscEV, cscFE, cscCF) = bases,coboundaries

julia&gt; FV # bases[2]
18-element Array{Array{Int64,1},1}:
 [1, 3, 4, 6]            
 [2, 3, 5, 6]            
 [7, 8, 9, 10]           
 [1, 2, 3, 7, 8]         
 [4, 6, 9, 10, 11, 12]   
 [5, 6, 11, 12]          
 [1, 4, 7, 9]            
 [2, 5, 11, 13]          
 [2, 8, 10, 11, 13]      
 [2, 3, 14, 15, 16]      
 [11, 12, 13, 17]        
 [11, 12, 13, 18, 19, 20]
 [2, 3, 13, 17]          
 [2, 13, 14, 18]         
 [15, 16, 19, 20]        
 [3, 6, 12, 15, 19]      
 [3, 6, 12, 17]          
 [14, 16, 18, 20]        

julia&gt; CV # bases[3]
3-element Array{Array{Int64,1},1}:
 [2, 3, 5, 6, 11, 12, 13, 14, 15, 16, 18, 19, 20]
 [2, 3, 5, 6, 11, 12, 13, 17]                    
 [1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 17]    </code></pre><p>Let note that the LAR of <code>FV</code> includes faces with 5 and 6 vertices, even non convex.  Also, the <code>CV</code> variable contains the LAR of the three solid parts the two cubes are split into. </p><pre><code class="language-julia">julia&gt; cscEV # coboundaries[1]
34×20 SparseMatrixCSC{Int8,Int64} with 68 stored entries: ...

julia&gt; cscFE # coboundaries[2]
18×34 SparseMatrixCSC{Int8,Int64} with 80 stored entries: ...

julia&gt; cscCF # coboundaries[3]
4×18 SparseMatrixCSC{Int8,Int64} with 36 stored entries: ...</code></pre><h2><a class="nav-anchor" id="Main-Interface-1" href="#Main-Interface-1">Main Interface</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.characteristicMatrix" href="#LinearAlgebraicRepresentation.characteristicMatrix"><code>LinearAlgebraicRepresentation.characteristicMatrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">characteristicMatrix( FV::Cells )::ChainOp</code></pre><p>Binary matrix representing by rows the <code>p</code>-cells of a cellular complex. The input parameter must be of <code>Cells</code> type. Return a sparse binary matrix, providing the basis of a <span>$Chain$</span> space of given dimension. Notice that the number of columns is equal to the number of vertices (0-cells).</p><p><strong>Example</strong></p><pre><code class="language-julia">V,(VV,EV,FV,CV) = cuboid([1.,1.,1.], true);

julia&gt; Matrix(characteristicMatrix(FV))
6×8 Array{Int8,2}:
1  1  1  1  0  0  0  0
0  0  0  0  1  1  1  1
1  1  0  0  1  1  0  0
0  0  1  1  0  0  1  1
1  0  1  0  1  0  1  0
0  1  0  1  0  1  0  1

julia&gt; Matrix(characteristicMatrix(CV))
1×8 Array{Int8,2}:
1  1  1  1  1  1  1  1

julia&gt; Matrix(characteristicMatrix(EV))
12×8 Array{Int8,2}:
1  1  0  0  0  0  0  0
0  0  1  1  0  0  0  0
0  0  0  0  1  1  0  0
0  0  0  0  0  0  1  1
1  0  1  0  0  0  0  0
0  1  0  1  0  0  0  0
0  0  0  0  1  0  1  0
0  0  0  0  0  1  0  1
1  0  0  0  1  0  0  0
0  1  0  0  0  1  0  0
0  0  1  0  0  0  1  0
0  0  0  1  0  0  0  1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/cvdlab/LinearAlgebraicRepresentation.jl/blob/a3d9adfa04c71ccb7fe93ab9ea1af1f92d013477/src/interface.jl#L3-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.boundary_1" href="#LinearAlgebraicRepresentation.boundary_1"><code>LinearAlgebraicRepresentation.boundary_1</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">boundary_1( EV::Cells )::ChainOp</code></pre><p>Computation of sparse signed boundary operator <span>$C_1 -&gt; C_0$</span>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; V,(VV,EV,FV,CV) = cuboid([1.,1.,1.], true);

julia&gt; EV
12-element Array{Array{Int64,1},1}:
[1, 2]
[3, 4]
...
[2, 6]
[3, 7]
[4, 8]

julia&gt; boundary_1( EV::Cells )
8×12 SparseMatrixCSC{Int8,Int64} with 24 stored entries:
[1 ,  1]  =  -1
[2 ,  1]  =  1
[3 ,  2]  =  -1
...       ...
[7 , 11]  =  1
[4 , 12]  =  -1
[8 , 12]  =  1

julia&gt; Matrix(boundary_1(EV::Cells))
8×12 Array{Int8,2}:
-1   0   0   0  -1   0   0   0  -1   0   0   0
1   0   0   0   0  -1   0   0   0  -1   0   0
0  -1   0   0   1   0   0   0   0   0  -1   0
0   1   0   0   0   1   0   0   0   0   0  -1
0   0  -1   0   0   0  -1   0   1   0   0   0
0   0   1   0   0   0   0  -1   0   1   0   0
0   0   0  -1   0   0   1   0   0   0   1   0
0   0   0   1   0   0   0   1   0   0   0   1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/cvdlab/LinearAlgebraicRepresentation.jl/blob/a3d9adfa04c71ccb7fe93ab9ea1af1f92d013477/src/interface.jl#L59-L98">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.coboundary_0" href="#LinearAlgebraicRepresentation.coboundary_0"><code>LinearAlgebraicRepresentation.coboundary_0</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">coboundary_0(EV::Lar.Cells)</code></pre><p>Return the <code>coboundary_0</code> signed operator <code>C_0</code> -&gt; <code>C_1</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/cvdlab/LinearAlgebraicRepresentation.jl/blob/a3d9adfa04c71ccb7fe93ab9ea1af1f92d013477/src/interface.jl#L110-L114">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.u_coboundary_1" href="#LinearAlgebraicRepresentation.u_coboundary_1"><code>LinearAlgebraicRepresentation.u_coboundary_1</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">u_coboundary_1( FV::Lar.Cells, EV::Lar.Cells, convex=true)::Lar.ChainOp</code></pre><p>Compute the sparse <em>unsigned</em> coboundary<em>1 operator ``C</em>1 -&gt; C_2`<code>. Notice that the output matrix is</code>m x n<code>, where</code>m<code>is the number of faces, and</code>n` is the number of edges.</p><p><strong>Examples</strong></p><p><strong>Cellular complex with convex-cells, and without outer cell</strong></p><pre><code class="language-julia">julia&gt; V,(VV,EV,FV,CV) = Lar.cuboid([1.,1.,1.], true);

julia&gt; u_coboundary_1(FV,EV)
6×12 SparseMatrixCSC{Int8,Int64} with 24 stored entries:
[1 ,  1]  =  1
[3 ,  1]  =  1
[1 ,  2]  =  1
[4 ,  2]  =  1
...		...
[4 , 11]  =  1
[5 , 11]  =  1
[4 , 12]  =  1
[6 , 12]  =  1

julia&gt; Matrix(u_coboundary_1(FV,EV))
6×12 Array{Int8,2}:
1  1  0  0  1  1  0  0  0  0  0  0
0  0  1  1  0  0  1  1  0  0  0  0
1  0  1  0  0  0  0  0  1  1  0  0
0  1  0  1  0  0  0  0  0  0  1  1
0  0  0  0  1  0  1  0  1  0  1  0
0  0  0  0  0  1  0  1  0  1  0  1

julia&gt; unsigned_boundary_2 = u_coboundary_1(FV,EV)&#39;;</code></pre><p>Compute the <em>Unsigned</em> <code>coboundary_1</code> operator matrix as product of two sparse characteristic matrices.</p><p><strong>Cellular complex with non-convex cells, and with outer cell</strong></p><pre><code class="language-julia">FV = [[1,2,3,4,5,17,16,12], # outer cell
[1,2,3,4,6,7,8,9,10,11,12,13,14,15],
[4,5,9,11,12,13,14,15,16,17],
[2,3,6,7], [8,9,10,11]]

EV = [[1,2],[2,3],[3,4],[4,5],[1,12],[2,6],[3,7],[4,9],[5,17],[6,7],[8,9],
[8,10],[9,11],[10,11],[11,15],[12,13],[12,16],[13,14],[14,15],[16,17]]

out = u_coboundary_1( FV::Lar.Cells, EV::Lar.Cells, false)</code></pre><p>In case of expected 2-chains with non-convex cells, instance the method with <code>convex = false</code>, in order to fix a possible redundancy of incidence values, induced by computation through multiplication of characteristic matrices. (Look at columns 2 and 13 before, generated by default).</p></div></div><a class="source-link" target="_blank" href="https://github.com/cvdlab/LinearAlgebraicRepresentation.jl/blob/a3d9adfa04c71ccb7fe93ab9ea1af1f92d013477/src/interface.jl#L208-L265">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.u_boundary_2" href="#LinearAlgebraicRepresentation.u_boundary_2"><code>LinearAlgebraicRepresentation.u_boundary_2</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">u_boundary_2(FV::Lar.Cells, EV::Lar.Cells)::Lar.ChainOp</code></pre><p>Return the unsigned <code>boundary_2</code> operator <code>C_2</code> -&gt; <code>C_1</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/cvdlab/LinearAlgebraicRepresentation.jl/blob/a3d9adfa04c71ccb7fe93ab9ea1af1f92d013477/src/interface.jl#L399-L403">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.coboundary_1" href="#LinearAlgebraicRepresentation.coboundary_1"><code>LinearAlgebraicRepresentation.coboundary_1</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">coboundary_1( FV::Lar.Cells, EV::Lar.Cells)::Lar.ChainOp</code></pre><p>Generate the <em>signed</em> sparse matrix of the coboundary_1 operator. For each row, start with the first incidence number positive (i.e. assign the orientation of the first edge to the 1-cycle of the face), then bounce back and forth between vertex columns/rows of EV and FE.</p><p><strong>Example</strong></p><p>julia&gt; Matrix(cscFE) 5×20 Array{Int8,2}:  1  1  1  1  1  0  0  0  1  0  0  0  0  0  0  0  1  0  0  1  1  0  1  0  1  1  1  1  0  1  1  1  0  1  1  1  0  1  1  0  0  0  0  1  0  0  0  1  1  0  0  0  1  0  1  1  1  1  1  1  0  1  0  0  0  1  1  0  0  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0</p></div></div><a class="source-link" target="_blank" href="https://github.com/cvdlab/LinearAlgebraicRepresentation.jl/blob/a3d9adfa04c71ccb7fe93ab9ea1af1f92d013477/src/interface.jl#L293-L310">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebraicRepresentation.chaincomplex" href="#LinearAlgebraicRepresentation.chaincomplex"><code>LinearAlgebraicRepresentation.chaincomplex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">chaincomplex( W::Points, EW::Cells )::Tuple{Array{Cells,1},Array{ChainOp,1}}</code></pre><p>Chain 2-complex construction from basis of 1-cells.</p><p>From the minimal input, construct the whole two-dimensional chain complex, i.e. the bases for linear spaces C<em>1 and C</em>2 of 1-chains and  2-chains, and the signed coboundary operators from C<em>0 to C</em>1 and from C<em>1 to C</em>2.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; W =
[0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0  2.0  2.0  2.0  2.0  3.0  3.0  3.0  3.0
0.0  1.0  2.0  3.0  0.0  1.0  2.0  3.0  0.0  1.0  2.0  3.0  0.0  1.0  2.0  3.0]
# output
2×16 Array{Float64,2}: ...

julia&gt; EW =
[[1, 2],[2, 3],[3, 4],[5, 6],[6, 7],[7, 8],[9, 10],[10, 11],[11, 12],[13, 14],
[14, 15],[15, 16],[1, 5],[2, 6],[3, 7],[4, 8],[5, 9],[6, 10],[7, 11],[8, 12],
[9, 13],[10, 14],[11, 15],[12, 16]]
# output
24-element Array{Array{Int64,1},1}: ...

julia&gt; V,bases,coboundaries = chaincomplex(W,EW)

julia&gt; bases[1]	# edges
24-element Array{Array{Int64,1},1}: ...

julia&gt; bases[2] # faces -- previously unknown !!
9-element Array{Array{Int64,1},1}: ...

julia&gt; coboundaries[1] # coboundary_1
24×16 SparseMatrixCSC{Int8,Int64} with 48 stored entries: ...

julia&gt; Matrix(coboundaries[2]) # coboundary_1: faces as oriented 1-cycles of edges
9×24 Array{Int8,2}:
-1  0  0  1  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0  0  0  0  0  0
0 -1  0  0  1  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0  0  0  0  0
0  0 -1  0  0  1  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0  0  0  0
0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0  0
0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  1 -1  0  0  0  0  0
0  0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  1 -1  0  0  0  0
0  0  0  0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  0  1 -1  0
0  0  0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  0  1 -1  0  0
0  0  0  0  0  0  0  0 -1  0  0  1  0  0  0  0  0  0  0  0  0  0  1 -1</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/cvdlab/LinearAlgebraicRepresentation.jl/blob/a3d9adfa04c71ccb7fe93ab9ea1af1f92d013477/src/interface.jl#L483-L532">source</a><div><div><pre><code class="language-none">chaincomplex( W::Points, FW::Cells, EW::Cells )
	::Tuple{ Array{Cells,1}, Array{ChainOp,1} }</code></pre><p>Chain 3-complex construction from bases of 2- and 1-cells.</p><p>From the minimal input, construct the whole two-dimensional chain complex, i.e. the bases for linear spaces C<em>1 and C</em>2 of 1-chains and  2-chains, and the signed coboundary operators from C<em>0 to C</em>1  and from C<em>1 to C</em>2.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; cube_1 = ([0 0 0 0 1 1 1 1; 0 0 1 1 0 0 1 1; 0 1 0 1 0 1 0 1],
[[1,2,3,4],[5,6,7,8],[1,2,5,6],[3,4,7,8],[1,3,5,7],[2,4,6,8]],
[[1,2],[3,4],[5,6],[7,8],[1,3],[2,4],[5,7],[6,8],[1,5],[2,6],[3,7],[4,8]] )

julia&gt; cube_2 = Lar.Struct([Lar.t(0,0,0.5), Lar.r(0,0,pi/3), cube_1])

julia&gt; V,FV,EV = Lar.struct2lar(Lar.Struct([ cube_1, cube_2 ]))

julia&gt; V,bases,coboundaries = Lar.chaincomplex(V,FV,EV)

julia&gt; (EV, FV, CV), (cscEV, cscFE, cscCF) = bases,coboundaries

julia&gt; FV # bases[2]
18-element Array{Array{Int64,1},1}:
[1, 3, 4, 6]
[2, 3, 5, 6]
[7, 8, 9, 10]
[1, 2, 3, 7, 8]
[4, 6, 9, 10, 11, 12]
[5, 6, 11, 12]
[1, 4, 7, 9]
[2, 5, 11, 13]
[2, 8, 10, 11, 13]
[2, 3, 14, 15, 16]
[11, 12, 13, 17]
[11, 12, 13, 18, 19, 20]
[2, 3, 13, 17]
[2, 13, 14, 18]
[15, 16, 19, 20]
[3, 6, 12, 15, 19]
[3, 6, 12, 17]
[14, 16, 18, 20]

julia&gt; CV # bases[3]
3-element Array{Array{Int64,1},1}:
[2, 3, 5, 6, 11, 12, 13, 14, 15, 16, 18, 19, 20]
[2, 3, 5, 6, 11, 12, 13, 17]
[1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 17]

julia&gt; cscEV # coboundaries[1]
34×20 SparseMatrixCSC{Int8,Int64} with 68 stored entries: ...

julia&gt; cscFE # coboundaries[2]
18×34 SparseMatrixCSC{Int8,Int64} with 80 stored entries: ...

julia&gt; cscCF # coboundaries[3]
4×18 SparseMatrixCSC{Int8,Int64} with 36 stored entries: ...</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/cvdlab/LinearAlgebraicRepresentation.jl/blob/a3d9adfa04c71ccb7fe93ab9ea1af1f92d013477/src/interface.jl#L557-L618">source</a></section><footer><hr/><a class="previous" href="../lar/"><span class="direction">Previous</span><span class="title">L.A.R. Intro</span></a><a class="next" href="../arrangement/"><span class="direction">Next</span><span class="title">Arrangement</span></a></footer></article></body></html>
