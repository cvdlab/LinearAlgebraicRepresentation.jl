<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Simplicial grids · LinearAlgebraicRepresentation.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="LinearAlgebraicRepresentation.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">LinearAlgebraicRepresentation.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../lar/">L.A.R. Intro</a></li><li><a class="tocitem" href="../interface/">Interface</a></li><li><a class="tocitem" href="../arrangement/">Arrangement</a></li><li><span class="tocitem">Parametric primitives</span><ul><li><a class="tocitem" href="../mapper/">Mapper</a></li><li><a class="tocitem" href="../struct/">Assemblies</a></li></ul></li><li><span class="tocitem">Grid generation</span><ul><li><a class="tocitem" href="../largrid/">Cuboidal grids</a></li><li class="is-active"><a class="tocitem" href>Simplicial grids</a><ul class="internal"><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li><li><a class="tocitem" href="#Main-Interface"><span>Main Interface</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../integr/">Domain integration</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Grid generation</a></li><li class="is-active"><a href>Simplicial grids</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Simplicial grids</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/cvdlab/LinearAlgebraicRepresentation.jl/blob/master/docs/src/simplexn.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Simplicial-complexes"><a class="docs-heading-anchor" href="#Simplicial-complexes">Simplicial complexes</a><a id="Simplicial-complexes-1"></a><a class="docs-heading-anchor-permalink" href="#Simplicial-complexes" title="Permalink"></a></h1><p>This module defines a minimal set of functions to generate a <em>dimension-independent</em> cellular complex of simplices. The name of the library was firstly used by  CAD Lab at University <span>$La Sapienza$</span> of Rome  in years 1987/88 when started working with dimension-independent simplicial complexes (see &quot;<a href="https://dl.acm.org/citation.cfm?doid=169728.169719">Dimension-independent modeling with simplicial complexes</a>&quot; ). The library provides  <strong>combinatorial algorithms</strong> for some basic functions of <em>geometric modelling with simplicial complexes</em>. In particular, provides the efficient creation of simplicial complexes generated by simplicial complexes of lower dimension, the production of simplicial grids of any dimension, and the extraction of <em>facets</em> (i.e. of <span>$(d-1)$</span>-faces) of simplicial of <span>$d$</span>-complexes. The main aim of the simplicial functions given in this library is to provide <em>optimal combinatorial algorithms</em>, whose time complexity is linear in the size of the output. Such a goal is achieved by calculating each cell in the output via <em>closed combinatorial formulas</em>, that do not require any searching nor data structure traversal to produce their results.</p><h3 id="Simplicial-extrusion"><a class="docs-heading-anchor" href="#Simplicial-extrusion">Simplicial extrusion</a><a id="Simplicial-extrusion-1"></a><a class="docs-heading-anchor-permalink" href="#Simplicial-extrusion" title="Permalink"></a></h3><p>Here we discuss the implementation of the linear extrusion of simplicial complexes according to the method discussed on papers &quot;<a href="https://dl.acm.org/citation.cfm?doid=169728.169719">Dimension-independent modeling with simplicial complexes</a>&quot; and &quot;<a href="https://www.sciencedirect.com/science/article/pii/001044859190080G">Extrusion and boundary evaluation for multidimensional polyhedra</a>&quot;. In synthesis, for each <span>$d$</span>-simplex in the input complex, we generate combinatorially a <span>$(d+1)$</span>-simplicial <em>tube</em>, i.e. a chain of <span>$d+1$</span> simplexes of dimension <span>$d+1$</span>. It can be shown that if the input simplices are a simplicial complex, then the output simplices are a simplicial complex too (i.e. are correctly glued together). </p><p>In other words, if the input is a <span>$d$</span>complex, where all <span>$d$</span>-cells either intersect along a common face or are pairwise disjoints, then the output is  a simplicial complex of dimension <span>$d+1$</span>. This method is <strong>computationally optimal</strong>, since it does not require any search or traversal of data structures. The algorithm just writes the output making a constant number <span>$O(1)$</span> of operation for each one of its <span>$n$</span> output <span>$d$</span>-cells, so that the time complexity is <span>$\Omega(n)$</span>, where <span>$n = d\,m$</span>, being <span>$m$</span> the number and <span>$d$</span> the dimension (and the storage size) of the input cells, represented as arrays of indices of vertices, using the <code>Cells</code> type.</p><p>The aim of the <code>extrudeSimplicial</code> function is  to generate the output model vertices and cells in a <em>multiple</em> extrusion of a LAR model. First note that the <code>model</code> variable contains a pair (<code>V</code>, <code>FV</code>), where <code>V</code> is the array of input vertices, and <code>FV</code> is the array of <span>$d$</span>-cells (given as list of lists of vertex indices), providing the  input representation of a LAR cellular complex. The <code>pattern</code> variable is a list of integers, whose absolute values provide the sizes of the ordered set of 1D subintervals (in local coords) specified by the <code>pattern</code> itself. Such subintervals are assembled in global coordinates, and each one of them is considered either <em>solid</em> or <em>empty</em> depending on the sign of the corresponding measure, which may be either positive (solid subinterval) or negative (void subinterval).  </p><p>Therefore, a value <code>pattern = [1,1,-1,1]</code> is interpreted as the 1D simplicial complex</p><p><code>[0,1]</code> <span>$\cup$</span> <code>[1,2]</code> <span>$\cup$</span> <code>[3,4]</code></p><p>with five vertices <code>W = [[0.0], [1.0], [2.0], [3.0], [4.0]]</code> and three 1-cells <code>[[0,1], [1,2], [3,4]]</code>.</p><p><code>V</code> is the list of input <span>$d$</span>-vertices (each given as a list of <span>$d$</span> coordinates); <code>coords</code> is a list of absolute translation parameters to be applied to <code>V</code> in order to generate the output vertices generated by the combinatorial extrusion algorithm. The <code>cellGroups</code> internal variable is used to select the groups of <span>$(d+1)$</span>-simplices corresponding to solid intervals in the input <code>pattern</code>.</p><h3 id="Simplicial-grids"><a class="docs-heading-anchor" href="#Simplicial-grids">Simplicial grids</a><a id="Simplicial-grids-1"></a><a class="docs-heading-anchor-permalink" href="#Simplicial-grids" title="Permalink"></a></h3><p>The generation of simplicial grids of any dimension and shape using the <code>simplexGrid</code> is amazingly simple. The input parameter <code>shape</code> is either a tuple or a list of integers used to specify the <em>shape</em> of the created array, i.e. both the number of its dimensions (given by <code>len(shape)</code>) and the <code>size</code> of each dimension <span>$k$</span> (given by the <code>shape[k]</code> element). The implementation starts from the LAR model of an empty simplicial  model (denoted as <code>VOID</code>, a predefined constant) and updates the <code>model</code> variable extruding it iteratively according to the specs given by <code>shape</code>. Just notice that the returned grid <code>model</code>usually has vertices with integer coordinates, that can be subsequently scaled and/or translated and/or mapped in any other way, according to the user needs.</p><h3 id="Facet-extraction-from-simplices"><a class="docs-heading-anchor" href="#Facet-extraction-from-simplices">Facet extraction from simplices</a><a id="Facet-extraction-from-simplices-1"></a><a class="docs-heading-anchor-permalink" href="#Facet-extraction-from-simplices" title="Permalink"></a></h3><p>A <span>$k$</span>-face of a <span>$d$</span>-simplex is defined as the convex hull of any subset of <span>$k$</span> vertices. A <span>$(d-1)$</span>-face of a <span>$d$</span>-simplex </p><p><span>$\sigma^d = \langle v_0, v_1, \ldots, v_d \rangle$</span></p><p>is also called a <em>facet</em>. Each of the <span>$d+1$</span> facets of <span>$\sigma^d$</span>, obtained by removing a vertex from <span>$\sigma^d$</span>, is a <span>$(d-1)$</span>-simplex. A simplex may be oriented in two different ways according to the permutation class of its vertices. The simplex <em>orientation</em> is so changed by either multiplying the simplex by -1, or by executing an odd number of exchanges of its vertices. </p><p>The chain of oriented boundary facets of <span>$\sigma^d$</span>, usually denoted as <span>$\partial \sigma^d$</span>, is generated combinatorially as follows:</p><p><span>$\partial\, \sigma^d = \sum_{k=0}^d (-1)^d \langle v_0, \ldots, v_{k-1}, v_{k+1}, \ldots, v_d \rangle$</span></p><p>The <code>larSimplexFacets</code> function, for estraction of non-oriented <span>$(d-1)$</span>-facets of <span>$d$</span>-dimensional simplices, returns a list of <span>$d$</span>-tuples of integers, i.e. the input LAR representation of the topology of a cellular complex. The final steps are used to remove the duplicated facets, by transforming the sorted facets into a <em>set of strings</em>, so removing the duplicated elements.</p><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><h3 id="Multidimensional-simplicial-extrusion"><a class="docs-heading-anchor" href="#Multidimensional-simplicial-extrusion">Multidimensional simplicial extrusion</a><a id="Multidimensional-simplicial-extrusion-1"></a><a class="docs-heading-anchor-permalink" href="#Multidimensional-simplicial-extrusion" title="Permalink"></a></h3><p>The algorithm for multimensional extrusion of a simplicial complex is implemented in the <code>extrudeSimplicial</code> function.  This one can be applied to 0-, 1-, 2-, ... simplicial <code>model</code>, to get a 1-, 2-, 3-, .... <code>model</code>.  A 1D <code>pattern</code> of linear <code>Array</code> type is used to specify how to decompose the added dimension.</p><p>The input and output <code>model</code> are a LAR model, i.e. a pair <code>(vertices, cells)</code>, whereas <code>pattern</code> is an array of <code>Int64</code>, to be used as lateral measures of the <em>extruded</em> model. Note that <code>pattern</code> elements are assumed as either <em>solid</em> or <em>empty</em> measures, according to their (+/-) sign.</p><pre><code class="language-julia">julia&gt; Lar = LinearAlgebraicRepresentation

julia&gt; V = [[0,0] [1,0] [2,0] [0,1] [1,1] [2,1] [0,2] [1,2] [2,2]]
2×9 Array{Int64,2}:
 0  1  2  0  1  2  0  1  2
 0  0  0  1  1  1  2  2  2

julia&gt; FV = [[1,2,4],[2,3,5],[3,5,6],[4,5,7],[5,7,8],[6,8,9]]
6-element Array{Array{Int64,1},1}:
 [1, 2, 4]
 [2, 3, 5]
 [3, 5, 6]
 [4, 5, 7]
 [5, 7, 8]
 [6, 8, 9]

julia&gt; pattern = repeat([1,2,-3],outer=4)
12-element Array{Int64,1}:
[1,2,-3,1,2,-3,1,2,-3,1,2,-3]

julia&gt; model = (V,FV)
([0 1 2 0 1 2 0 1 2; 0 0 0 1 1 1 2 2 2], 
Array{Int64,1}[[1, 2, 4], [2, 3, 5], [3, 5, 6], [4, 5, 7], [5, 7, 8], [6, 8, 9]])

julia&gt; W,FW = Lar.extrudeSimplicial(model, pattern)

julia&gt; W
3×117 Array{Int64,2}:
 0  1  2  0  1  2  0  1  2   …   0   1   2   0   1   2   0   1   2   0   1   2
 0  0  0  1  1  1  2  2  2       2   2   2   0   0   0   1   1   1   2   2   2
 0  0  0  0  0  0  0  0  0      21  21  21  24  24  24  24  24  24  24  24  24

julia&gt; FW
144-element Array{Array{Int64,1},1}:
 [1, 2, 4, 10]      
 [2, 4, 10, 11]     
 ⋮                  
 [96, 98, 99, 105]  
 [98, 99, 105, 107] 
 [99, 105, 107, 108]

julia&gt; Plasm.view(W,FW)</code></pre><h3 id="Multidimensional-grids-of-simplices"><a class="docs-heading-anchor" href="#Multidimensional-grids-of-simplices">Multidimensional grids of simplices</a><a id="Multidimensional-grids-of-simplices-1"></a><a class="docs-heading-anchor-permalink" href="#Multidimensional-grids-of-simplices" title="Permalink"></a></h3><p>Generate a simplicial complex decomposition of a cubical grid of <span>$d$</span>-cuboids, where <span>$d$</span> is the length of <code>shape=[</code><code>n_1, n_2, ..., n_d</code><code>]</code> array, so that <code>shape</code> defines the grid dimension <span>$d$</span> and size <span>$n_1 \times n_2 \times ... \times n_d$</span>  as a <span>$d$</span>-dimensional array of <em>cubes</em>. Vertices (0-cells) of the grid have <code>Int64</code> coordinates.</p><pre><code class="language-julia">julia&gt; Lar.simplexGrid([0]) # 0-dimensional simplicial complex
# output
([0], Array{Int64,1}[])

julia&gt; V,EV = Lar.simplexGrid([1]) # 1-dimensional simplicial complex
# output
([0 1], Array{Int64,1}[[1, 2]])

julia&gt; V,FV = Lar.simplexGrid([1,1]) # 2-dimensional simplicial complex
# output
([0 1 0 1; 0 0 1 1], Array{Int64,1}[[1, 2, 3], [2, 3, 4]])

julia&gt; V,CV = Lar.simplexGrid([10,10,1]) # 3-dimensional simplicial complex
# output
([0 1 … 9 10; 0 0 … 10 10; 0 0 … 1 1], Array{Int64,1}[[1, 2, 12, 122], [2, 12, 122, 123], [12, 122, 123, 133], [2, 12, 13, 123], [12, 13, 123, 133], [13, 123, 133, 134], [2, 3, 13, 123], [3, 13, 123, 124], [13, 123, 124, 134], [3, 13, 14, 124]  …  [119, 229, 230, 240], [109, 119, 120, 230], [119, 120, 230, 240], [120, 230, 240, 241], [109, 110, 120, 230], [110, 120, 230, 231], [120, 230, 231, 241], [110, 120, 121, 231], [120, 121, 231, 241], [121, 231, 241, 242]])

julia&gt; V
# output
3×242 Array{Int64,2}:
 0  1  2  3  4  5  6  7  8  9  10  0  1  2  3  …   1   2   3   4   5   6   7   8   9  10
 0  0  0  0  0  0  0  0  0  0   0  1  1  1  1     10  10  10  10  10  10  10  10  10  10
 0  0  0  0  0  0  0  0  0  0   0  0  0  0  0      1   1   1   1   1   1   1   1   1   1


julia&gt; using Plasm

julia&gt; hpc = Plasm.hpc_exploded(V,CV) # exploded visualization of the simplicial grid

julia&gt; Plasm.view(hpc)

julia&gt; V,HV = simplexGrid([1,1,1,1]) # 4-dim simplicial complex
# output
([0 1 … 0 1; 0 0 … 1 1; 0 0 … 1 1; 0 0 … 1 1], Array{Int64,1}[[1, 2, 3, 5, 9], [2, 3, 5, 9, 10], [3, 5, 9, 10, 11], [5, 9, 10, 11, 13], [2, 3, 5, 6, 10], [3, 5, 6, 10, 11], [5, 6, 10, 11, 13], [6, 10, 11, 13, 14], [3, 5, 6, 7, 11], [5, 6, 7, 11, 13]  …  [4, 6, 10, 11, 12], [6, 10, 11, 12, 14], [3, 4, 6, 7, 11], [4, 6, 7, 11, 12], [6, 7, 11, 12, 14], [7, 11, 12, 14, 15], [4, 6, 7, 8, 12], [6, 7, 8, 12, 14], [7, 8, 12, 14, 15], [8, 12, 14, 15, 16]])</code></pre><h3 id="Facets-of-multidimensional-simplicial-complexes"><a class="docs-heading-anchor" href="#Facets-of-multidimensional-simplicial-complexes">Facets of multidimensional simplicial complexes</a><a id="Facets-of-multidimensional-simplicial-complexes-1"></a><a class="docs-heading-anchor-permalink" href="#Facets-of-multidimensional-simplicial-complexes" title="Permalink"></a></h3><p>Compute the <code>(d-1)</code>-skeleton (set of <code>facets</code>) of a simplicial <code>d</code>-complex. Each of the <span>$d+1$</span> facets of of a <span>$d$</span>-simplex <span>$\sigma^d$</span>, obtained by removing a vertex from <span>$\sigma^d$</span>, is a <span>$(d-1)$</span>-simplex.</p><pre><code class="language-julia">julia&gt; V,FV = Lar.simplexGrid([1,1]) # 2-dimensional complex
# output
([0 1 0 1; 0 0 1 1], Array{Int64,1}[[1, 2, 3], [2, 3, 4]])

julia&gt; Plasm.view(V,FV)

julia&gt; W,CW = Lar.extrudeSimplicial((V,FV), [1])
([0.0 1.0 … 0.0 1.0; 0.0 0.0 … 1.0 1.0; 0.0 0.0 … 1.0 1.0], 
Array{Int64,1}[[1,2,3,5],[2,3,5,6],[3,5,6,7],[2,3,4,6],[3,4,6,7],[4,6,7,8]])

julia&gt; FW = Lar.simplexFacets(CW)
18-element Array{Any,1}:
[[1,3,5],[5,6,7],[3,5,7],[3,6,7],[4,6,7],[4,7,8],[4,6,8],
[6,7,8],[3,5,6],[2,3,5],[2,3,4],[3,4,7],[1,2,3],[2,4,6],[2,5,6],
[1,2,5],[2,3,6],[3,4,6]]

julia&gt; Plasm.view(W,FW)</code></pre><h2 id="Main-Interface"><a class="docs-heading-anchor" href="#Main-Interface">Main Interface</a><a id="Main-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Main-Interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebraicRepresentation.simplexGrid" href="#LinearAlgebraicRepresentation.simplexGrid"><code>LinearAlgebraicRepresentation.simplexGrid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">simplexGrid(shape::Array)::LAR</code></pre><p>Generate a simplicial complex decomposition of a cubical grid of <span>$d$</span>-cuboids, where <span>$d$</span> is the length of <code>shape</code> array. Vertices (0-cells) of the grid have <code>Int64</code> coordinates.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; simplexGrid([0]) # 0-dimensional complex
# output
([0], Array{Int64,1}[])

julia&gt; V,EV = simplexGrid([1]) # 1-dimensional complex
# output
([0 1], Array{Int64,1}[[1, 2]])

julia&gt; V,FV = simplexGrid([1,1]) # 2-dimensional complex
# output
([0 1 0 1; 0 0 1 1], Array{Int64,1}[[1, 2, 3], [2, 3, 4]])

julia&gt; V,CV = simplexGrid([10,10,1]) # 3-dimensional complex
# output
([0 1 … 9 10; 0 0 … 10 10; 0 0 … 1 1], Array{Int64,1}[[1, 2, 12, 122], [2, 12, 122, 123], [12, 122, 123, 133], [2, 12, 13, 123], [12, 13, 123, 133], [13, 123, 133, 134], [2, 3, 13, 123], [3, 13, 123, 124], [13, 123, 124, 134], [3, 13, 14, 124]  …  [119, 229, 230, 240], [109, 119, 120, 230], [119, 120, 230, 240], [120, 230, 240, 241], [109, 110, 120, 230], [110, 120, 230, 231], [120, 230, 231, 241], [110, 120, 121, 231], [120, 121, 231, 241], [121, 231, 241, 242]])

julia&gt; V
# output
3×242 Array{Int64,2}:
 0  1  2  3  4  5  6  7  8  9  10  0  1  2  3  …   1   2   3   4   5   6   7   8   9  10
 0  0  0  0  0  0  0  0  0  0   0  1  1  1  1     10  10  10  10  10  10  10  10  10  10
 0  0  0  0  0  0  0  0  0  0   0  0  0  0  0      1   1   1   1   1   1   1   1   1   1

julia&gt; using Plasm

julia&gt; hpc = Plasm.lar2exploded_hpc(V,CV) # exploded visualization of the grid

julia&gt; Plasm.view(hpc)

julia&gt; V,HV = simplexGrid([1,1,1,1]) # 4-dim cellular complex from the 4D simplex
# output
([0 1 … 0 1; 0 0 … 1 1; 0 0 … 1 1; 0 0 … 1 1], Array{Int64,1}[[1, 2, 3, 5, 9], [2, 3, 5, 9, 10], [3, 5, 9, 10, 11], [5, 9, 10, 11, 13], [2, 3, 5, 6, 10], [3, 5, 6, 10, 11], [5, 6, 10, 11, 13], [6, 10, 11, 13, 14], [3, 5, 6, 7, 11], [5, 6, 7, 11, 13]  …  [4, 6, 10, 11, 12], [6, 10, 11, 12, 14], [3, 4, 6, 7, 11], [4, 6, 7, 11, 12], [6, 7, 11, 12, 14], [7, 11, 12, 14, 15], [4, 6, 7, 8, 12], [6, 7, 8, 12, 14], [7, 8, 12, 14, 15], [8, 12, 14, 15, 16]])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvdlab/LinearAlgebraicRepresentation.jl/blob/b4bb4fc5259eb8667af3074124738e6221ed5ce2/src/simplexn.jl#L114-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebraicRepresentation.simplexFacets" href="#LinearAlgebraicRepresentation.simplexFacets"><code>LinearAlgebraicRepresentation.simplexFacets</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">simplexFacets(simplices::Cells)::Cells</code></pre><p>Compute the <code>(d-1)</code>-skeleton (unoriented set of <code>facets</code>) of a simplicial <code>d</code>-complex.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; V,FV = Lar.simplexGrid([1,1]) # 2-dimensional complex
# output
([0 1 0 1; 0 0 1 1], Array{Int64,1}[[1, 2, 3], [2, 3, 4]])

julia&gt; Plasm.view(V,FV)

julia&gt; W,CW = Lar.extrudeSimplicial((V,FV), [1])
([0.0 1.0 … 0.0 1.0; 0.0 0.0 … 1.0 1.0; 0.0 0.0 … 1.0 1.0],
Array{Int64,1}[[1,2,3,5],[2,3,5,6],[3,5,6,7],[2,3,4,6],[3,4,6,7],[4,6,7,8]])

julia&gt; FW = Lar.simplexFacets(CW)
18-element Array{Any,1}:
[[1,3,5],[5,6,7],[3,5,7],[3,6,7],[4,6,7],[4,7,8],[4,6,8],
[6,7,8],[3,5,6],[2,3,5],[2,3,4],[3,4,7],[1,2,3],[2,4,6],[2,5,6],
[1,2,5],[2,3,6],[3,4,6]]

julia&gt; Plasm.view(W,FW)</code></pre><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; V,(VV,EV,FV,CV) = Lar.cuboidGrid([3,3,3],true)

julia&gt; TV = Lar.simplexFacets(CV)

julia&gt; Plasm.view(V,TV)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvdlab/LinearAlgebraicRepresentation.jl/blob/b4bb4fc5259eb8667af3074124738e6221ed5ce2/src/simplexn.jl#L169-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebraicRepresentation.extrudeSimplicial" href="#LinearAlgebraicRepresentation.extrudeSimplicial"><code>LinearAlgebraicRepresentation.extrudeSimplicial</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">extrudeSimplicial(model::LAR, pattern::Array)::LAR</code></pre><p>Algorithm for multimensional extrusion of a simplicial complex. Can be applied to 0-, 1-, 2-, ... simplicial models, to get a 1-, 2-, 3-, .... model. The pattern <code>Array</code> is used to specify how to decompose the added dimension.</p><p>A <code>model</code> is a LAR model, i.e. a pair (vertices,cells) to be extruded, whereas pattern is an array of <code>Int64</code>, to be used as lateral measures of the <em>extruded</em> model. <code>pattern</code> elements are assumed as either <em>solid</em> or <em>empty</em> measures, according to their (+/-) sign.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; V = [[0,0] [1,0] [2,0] [0,1] [1,1] [2,1] [0,2] [1,2] [2,2]];

julia&gt; FV = [[1,2,4],[2,3,5],[3,5,6],[4,5,7],[5,7,8],[6,8,9]];

julia&gt; pattern = repeat([1,2,-3],outer=4);

julia&gt; model = (V,FV);

julia&gt; W,FW = extrudeSimplicial(model, pattern);

julia&gt; Plasm.view(W,FW)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvdlab/LinearAlgebraicRepresentation.jl/blob/b4bb4fc5259eb8667af3074124738e6221ed5ce2/src/simplexn.jl#L40-L63">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../largrid/">« Cuboidal grids</a><a class="docs-footer-nextpage" href="../integr/">Domain integration »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 20 March 2021 17:33">Saturday 20 March 2021</span>. Using Julia version 1.5.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
